<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时网络拓扑可视化器</title>
    <style>
        :root {
            --primary-color: #0c70f2;
            --secondary-color: #05d9e8;
            --bg-color: #0a192f;
            --text-color: #d8e3e7;
            --card-bg: rgba(13, 28, 50, 0.8);
            --accent-color: #01c38d;
            --error-color: #ff2e63;
            --slider-track: rgba(255, 255, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(5, 217, 232, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(1, 195, 141, 0.05) 0%, transparent 50%);
        }

        .container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            font-size: 1.8rem;
            color: var(--secondary-color);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1::before {
            content: '';
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .tools {
            display: flex;
            gap: 15px;
        }

        .tools button {
            background-color: rgba(12, 112, 242, 0.2);
            border: 1px solid var(--primary-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .tools button:hover {
            background-color: rgba(12, 112, 242, 0.4);
        }

        .tools button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .visualization-area {
            height: 75vh;
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            position: relative;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
        }

        .visualization-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .visualization-header h2 {
            font-size: 1.2rem;
            font-weight: 500;
        }

        .visualization-header .status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--accent-color);
            box-shadow: 0 0 5px var(--accent-color);
        }

        #diagram-container {
            flex: 1;
            overflow: auto;
            padding: 10px;
            position: relative;
        }

        #diagram {
            width: 100%;
            height: 100%;
        }

        .visualization-info {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(10, 25, 47, 0.85);
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid var(--secondary-color);
            max-width: 300px;
            font-size: 0.85rem;
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(4px);
            transform: translateX(-110%);
            transition: transform 0.3s ease;
        }

        .visualization-info.show {
            transform: translateX(0);
        }

        .info-toggle {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(12, 112, 242, 0.3);
            border: 1px solid var(--primary-color);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 11;
            transition: all 0.3s ease;
        }

        .info-toggle:hover {
            background-color: rgba(12, 112, 242, 0.5);
        }

        .info-toggle.active {
            background-color: var(--primary-color);
            color: white;
            left: 300px;
        }

        .visualization-info h3 {
            color: var(--secondary-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .visualization-info p {
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }

        .visualization-info .value {
            font-weight: 500;
            color: white;
        }

        .controls-area {
            background-color: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            padding: 20px;
            flex: 1;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .controls-header h2 {
            font-size: 1.2rem;
            font-weight: 500;
        }

        .controls-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-group {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .control-group h3 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: var(--secondary-color);
            font-weight: 500;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 12px;
        }

        .control-item {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }

        select, input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 0.9rem;
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(12, 112, 242, 0.2);
        }

        .range-control {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .range-control .range-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 3px;
        }

        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--slider-track);
            outline: none;
            transition: all 0.2s;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(12, 112, 242, 0.5);
        }

        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(12, 112, 242, 0.5);
            border: none;
        }

        .range-slider:hover::-webkit-slider-thumb {
            background: var(--secondary-color);
        }

        .range-slider:hover::-moz-range-thumb {
            background: var(--secondary-color);
        }

        .action-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .action-buttons button {
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .primary-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
        }

        .primary-btn:hover {
            background-color: #0e59b4;
            box-shadow: 0 0 10px rgba(12, 112, 242, 0.5);
        }

        .secondary-btn {
            background-color: transparent;
            color: var(--text-color);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .secondary-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* D3.js SVG Styles */
        .spine, .leaf {
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1;
        }

        .spine {
            fill: var(--primary-color);
        }

        .leaf {
            fill: var(--secondary-color);
        }

        .server {
            fill: var(--accent-color);
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1;
        }

        path {
            transition: stroke 0.3s;
        }

        path:hover {
            stroke: var(--secondary-color);
            stroke-width: 1;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background-color: rgba(10, 25, 47, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -100%);
            margin-top: -10px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid rgba(10, 25, 47, 0.9);
        }

        /* Loading indicator */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(10, 25, 47, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--secondary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Responsiveness */
        @media (max-width: 768px) {
            .controls-content {
                grid-template-columns: 1fr;
            }
            
            .visualization-area {
                height: 60vh;
            }
            
            .info-toggle.active {
                left: 280px;
            }
            
            .visualization-info {
                max-width: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>网络拓扑可视化</h1>
            <div class="tools">
                <button id="zoomFitBtn">适应窗口</button>
                <button id="toggleGridBtn">显示网格</button>
                <button id="exportSvgBtn">导出SVG</button>
            </div>
        </header>

        <div class="main-content">
            <div class="visualization-area">
                <div class="visualization-header">
                    <h2>InfiniBand Fabric 拓扑图</h2>
                    <div class="status">
                        <div class="status-dot"></div>
                        <span id="statusText">就绪</span>
                    </div>
                </div>
                
                <div class="info-toggle" id="infoToggle">i</div>
                <div class="visualization-info" id="infoPanel">
                    <h3>拓扑信息</h3>
                    <p>交换机类型: <span id="info-switchType" class="value">QM9700</span></p>
                    <p>网卡类型: <span id="info-networkCardType" class="value">400G</span></p>
                    <p>可扩展单元数量: <span id="info-suCount" class="value">2</span></p>
                    <p>Spine 交换机数量: <span id="info-spineCount" class="value">8</span></p>
                    <p>Leaf 交换机数量: <span id="info-leafCount" class="value">16</span></p>
                    <p>服务器数量: <span id="info-serverCount" class="value">128</span></p>
                    <p>总端口数: <span id="info-portCount" class="value">1536</span></p>
                    <p>总线缆数: <span id="info-cableCount" class="value">1152</span></p>
                </div>
                
                <div id="diagram-container">
                    <div id="diagram"></div>
                </div>
                
                <div id="tooltip" class="tooltip"></div>
            </div>

            <div class="controls-area">
                <div class="controls-header">
                    <h2>参数控制面板</h2>
                </div>
                
                <div class="controls-content">
                    <div class="control-group">
                        <h3>基本配置</h3>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="switchType">交换机类型</label>
                                <select id="switchType">
                                    <option value="QM8700">QM8700 (40-port)</option>
                                    <option value="QM9700" selected>QM9700 (64-port)</option>
                                    <option value="Q3400">Q3400 (144-port)</option>
                                    <option value="SN5600">SN5600 (128-port)</option>
                                </select>
                            </div>
                            <div class="control-item">
                                <label for="networkCardType">网卡类型</label>
                                <select id="networkCardType">
                                    <option value="200G">200G</option>
                                    <option value="400G" selected>400G</option>
                                    <option value="800G">800G</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h3>服务器配置</h3>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="numServers">服务器数量</label>
                                <input type="number" id="numServers" min="1" value="128" max="1000">
                            </div>
                            <div class="control-item">
                                <label for="numNetworkCardsPerServer">每服务器网卡数</label>
                                <select id="numNetworkCardsPerServer">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="4">4</option>
                                    <option value="8" selected>8</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h3>图表布局</h3>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="serversPerRow">每行服务器数</label>
                                <select id="serversPerRow">
                                    <option value="4">4</option>
                                    <option value="8" selected>8</option>
                                    <option value="10">10</option>
                                    <option value="12">12</option>
                                    <option value="16">16</option>
                                </select>
                            </div>
                            <div class="control-item">
                                <label for="diagramHeight">图表高度 (px)</label>
                                <input type="number" id="diagramHeight" min="600" max="2000" value="1000" step="50">
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h3>距离设置</h3>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="spineLeafDistance">Spine-Leaf 距离</label>
                                <div class="range-control">
                                    <input type="range" id="spineLeafDistance" class="range-slider" min="100" max="500" value="200" step="10">
                                    <div class="range-info">
                                        <span>100px</span>
                                        <span id="spineLeafValue">200px</span>
                                        <span>500px</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="leafNodeDistance">Leaf-Node 距离</label>
                                <div class="range-control">
                                    <input type="range" id="leafNodeDistance" class="range-slider" min="100" max="500" value="120" step="10">
                                    <div class="range-info">
                                        <span>100px</span>
                                        <span id="leafNodeValue">120px</span>
                                        <span>500px</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-item">
                                <label for="nodeRowSpacing">节点行间距</label>
                                <div class="range-control">
                                    <input type="range" id="nodeRowSpacing" class="range-slider" min="20" max="200" value="60" step="5">
                                    <div class="range-info">
                                        <span>20px</span>
                                        <span id="nodeRowValue">60px</span>
                                        <span>200px</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button id="resetButton" class="secondary-btn">重置参数</button>
                    <button id="calculateButton" class="primary-btn">计算拓扑</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // 初始化变量
        let diagram, svg, connectionsGroup, nodesGroup;
        let tooltip = document.getElementById('tooltip');
        let isDragging = false;
        let lastX, lastY;
        
        // DOM元素
        const infoToggle = document.getElementById('infoToggle');
        const infoPanel = document.getElementById('infoPanel');
        const calculateButton = document.getElementById('calculateButton');
        const resetButton = document.getElementById('resetButton');
        const zoomFitBtn = document.getElementById('zoomFitBtn');
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const exportSvgBtn = document.getElementById('exportSvgBtn');
        
        // 范围滑块值显示
        const spineLeafSlider = document.getElementById('spineLeafDistance');
        const leafNodeSlider = document.getElementById('leafNodeDistance');
        const nodeRowSlider = document.getElementById('nodeRowSpacing');
        const spineLeafValue = document.getElementById('spineLeafValue');
        const leafNodeValue = document.getElementById('leafNodeValue');
        const nodeRowValue = document.getElementById('nodeRowValue');
        
        // 初始化图表容器
        diagram = d3.select("#diagram");
        
        // 初始绘制拓扑图
        calculateAndDraw();
        
        // 绑定信息面板切换
        infoToggle.addEventListener('click', function() {
            this.classList.toggle('active');
            infoPanel.classList.toggle('show');
        });
        
        // 绑定工具栏按钮事件
        zoomFitBtn.addEventListener('click', zoomToFit);
        toggleGridBtn.addEventListener('click', toggleGrid);
        exportSvgBtn.addEventListener('click', exportSVG);
        
        // 绑定计算按钮事件
        calculateButton.addEventListener('click', calculateAndDraw);
        
        // 绑定重置按钮事件
        resetButton.addEventListener('click', resetParameters);
        
        // 绑定交换机类型变更事件
        document.getElementById('switchType').addEventListener('change', updateNetworkCardOptions);
        
        // 绑定范围滑块值更新
        spineLeafSlider.addEventListener('input', function() {
            spineLeafValue.textContent = this.value + 'px';
        });
        
        leafNodeSlider.addEventListener('input', function() {
            leafNodeValue.textContent = this.value + 'px';
        });
        
        nodeRowSlider.addEventListener('input', function() {
            nodeRowValue.textContent = this.value + 'px';
        });
        
        function updateNetworkCardOptions() {
            const switchType = document.getElementById('switchType').value;
            const networkCardSelect = document.getElementById('networkCardType');
            
            switch(switchType) {
                case 'QM8700':
                    networkCardSelect.value = '200G';
                    break;
                case 'QM9700':
                case 'SN5600':
                    networkCardSelect.value = '400G';
                    break;
                case 'Q3400':
                    networkCardSelect.value = '800G';
                    break;
            }
        }
        
        function calculateAndDraw() {
            showLoading();
            updateStatusText("计算中...");
            
            // 为了模拟处理效果，添加延迟
            setTimeout(() => {
                const switchType = document.getElementById('switchType').value;
                const networkCardType = document.getElementById('networkCardType').value;
                const numServers = parseInt(document.getElementById('numServers').value);
                const numNetworkCardsPerServer = parseInt(document.getElementById('numNetworkCardsPerServer').value);
                const spineLeafDistance = parseInt(document.getElementById('spineLeafDistance').value);
                const leafNodeDistance = parseInt(document.getElementById('leafNodeDistance').value);
                const serversPerRow = parseInt(document.getElementById('serversPerRow').value);
                const diagramHeight = parseInt(document.getElementById('diagramHeight').value);
                const nodeRowSpacing = parseInt(document.getElementById('nodeRowSpacing').value);
                
                let switchPorts, leafUplinks, serversPerSU, possibleSpineCounts;
                
                switch(switchType) {
                    case 'QM8700':
                        switchPorts = 40;
                        leafUplinks = 20;
                        serversPerSU = 20;
                        possibleSpineCounts = [1, 2, 4, 5, 10, 20];
                        break;
                    case 'QM9700':
                        switchPorts = 64;
                        leafUplinks = 32;
                        serversPerSU = 32;
                        possibleSpineCounts = [1, 2, 4, 8, 16, 32];
                        break;
                    case 'Q3400':
                        switchPorts = 144;
                        leafUplinks = 72;
                        serversPerSU = 72;
                        possibleSpineCounts = [1, 2, 3, 4, 6, 8, 9, 12, 18, 24, 36, 72];
                        break;
                    case 'SN5600':
                        switchPorts = 128;
                        leafUplinks = 64;
                        serversPerSU = 64;
                        possibleSpineCounts = [1, 2, 4, 8, 16, 32, 64];
                        break;
                }
                
                const numSU = Math.ceil(numServers / serversPerSU);
                const numLeafSwitchesPerSU = numNetworkCardsPerServer;
                const numLeafSwitches = numSU * numLeafSwitchesPerSU;
                const numSpineSwitches = possibleSpineCounts.find(count => count >= numLeafSwitches * leafUplinks / switchPorts) || possibleSpineCounts[possibleSpineCounts.length - 1];
                const totalPorts = numLeafSwitches * switchPorts + numSpineSwitches * switchPorts;
                const totalCables = numServers * numNetworkCardsPerServer + numLeafSwitches * numSpineSwitches;
                
                // 更新信息面板
                document.getElementById('info-switchType').textContent = switchType;
                document.getElementById('info-networkCardType').textContent = networkCardType;
                document.getElementById('info-suCount').textContent = numSU;
                document.getElementById('info-spineCount').textContent = numSpineSwitches;
                document.getElementById('info-leafCount').textContent = numLeafSwitches;
                document.getElementById('info-serverCount').textContent = numServers;
                document.getElementById('info-portCount').textContent = totalPorts;
                document.getElementById('info-cableCount').textContent = totalCables;
                
                // 绘制拓扑图
                drawTopology(numSU, numSpineSwitches, numLeafSwitches, numServers, numNetworkCardsPerServer, serversPerSU, spineLeafDistance, leafNodeDistance, serversPerRow, diagramHeight, nodeRowSpacing);
                
                // 更新状态
                updateStatusText("已完成");
                hideLoading();
            }, 500);
        }
        
        function drawTopology(numSU, numSpine, numLeaf, numServers, numNetworkCardsPerServer, serversPerSU, spineLeafDistance, leafNodeDistance, serversPerRow, diagramHeight, nodeRowSpacing) {
            // 调整宽度基于是否显示所有元素或仅部分元素
            let displayWidth;
            if (numSU <= 2) {
                // 对于所有元素的完整宽度
                displayWidth = Math.max(Math.min(window.innerWidth - 40, 1600), numLeaf * 80);
            } else {
                // 对于简化视图的减少宽度 - 不需要完整宽度
                displayWidth = Math.max(Math.min(window.innerWidth - 40, 1600), 800);
            }
            
            const width = displayWidth;
            const height = diagramHeight;
            const spineY = 50;
            const leafY = spineY + spineLeafDistance;
            const serverY = leafY + leafNodeDistance;
            
            // 清除旧图表
            d3.select("#diagram").selectAll("*").remove();
            
            // 创建新SVG
            svg = d3.select("#diagram")
                .append("svg")
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("width", width)
                .attr("height", height);
            
            // 添加缩放功能
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", function(event) {
                    container.attr("transform", event.transform);
                });
            
            svg.call(zoom);
            
            // 创建主容器组
            const container = svg.append("g");
            
            // 创建连接和节点组
            connectionsGroup = container.append("g").attr("class", "connections");
            nodesGroup = container.append("g").attr("class", "nodes");
            
            // 添加网格（默认隐藏）
            const gridSize = 50;
            const grid = container.append("g")
                .attr("class", "grid")
                .attr("display", "none");
                
            for (let x = 0; x < width; x += gridSize) {
                grid.append("line")
                    .attr("x1", x)
                    .attr("y1", 0)
                    .attr("x2", x)
                    .attr("y2", height)
                    .attr("stroke", "rgba(255, 255, 255, 0.1)")
                    .attr("stroke-width", 0.5);
            }
            
            for (let y = 0; y < height; y += gridSize) {
                grid.append("line")
                    .attr("x1", 0)
                    .attr("y1", y)
                    .attr("x2", width)
                    .attr("y2", y)
                    .attr("stroke", "rgba(255, 255, 255, 0.1)")
                    .attr("stroke-width", 0.5);
            }
            
            // 确定基于总数量显示哪些Spine交换机
            let spinesToDisplay = [];
            if (numSpine <= 8) {
                // 如果8个或更少spine，显示所有
                spinesToDisplay = Array.from({ length: numSpine }, (_, i) => i);
            } else {
                // 如果超过8个spine，显示前4个和后4个
                for (let i = 0; i < 4; i++) {
                    spinesToDisplay.push(i);              // 前4个
                }
                for (let i = numSpine - 4; i < numSpine; i++) {
                    spinesToDisplay.push(i);              // 后4个
                }
            }
            
            // 计算spine交换机X位置的函数
            const spineX = d => {
                if (numSpine <= 8) {
                    // 8个或更少spine的原始计算
                    return (width / (numSpine + 1)) * (d + 1);
                } else {
                    // 显示超过8个spine时的修改计算
                    if (d < 4) {
                        // 前4个spine使用左侧45%的宽度
                        return width * (0.1 + 0.35 * (d / 4));
                    } else {
                        // 后4个spine使用右侧45%的宽度
                        return width * (0.6 + 0.35 * ((d - (numSpine - 4)) / 4));
                    }
                }
            };
            
            // 仅为显示的spine创建矩形
            spinesToDisplay.forEach(spineIndex => {
                const x = spineX(spineIndex);
                const rect = nodesGroup.append("rect")
                    .attr("class", "spine")
                    .attr("x", x - 30)
                    .attr("y", spineY)
                    .attr("width", 60)
                    .attr("height", 30)
                    .attr("rx", 4)
                    .attr("ry", 4);
                    
                // 添加鼠标悬停事件
                rect.on("mouseover", function(event) {
                    showTooltip(event, `Spine ${spineIndex + 1}<br>${numLeaf} 连接`);
                })
                .on("mousemove", function(event) {
                    moveTooltip(event);
                })
                .on("mouseout", function() {
                    hideTooltip();
                });
                    
                nodesGroup.append("text")
                    .attr("class", "spine-label")
                    .attr("x", x)
                    .attr("y", spineY + 15)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "white")
                    .text(`Spine ${spineIndex + 1}`);
            });
            
            // 如果不显示所有spine，添加省略号
            if (numSpine > 8) {
                nodesGroup.append("text")
                    .attr("x", width / 2)
                    .attr("y", spineY + 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#0c70f2")
                    .text("...");
            }
            
            // 确定基于总数量和SU显示哪些Leaf交换机
            let leavesToDisplay = [];
            if (numSU <= 2 || numLeaf <= 8) {
                // 如果2个或更少SU或8个或更少叶子，显示所有叶子
                leavesToDisplay = Array.from({ length: numLeaf }, (_, i) => i);
            } else {
                // 如果3+个SU和9+个叶子，仅显示部分叶子
                const leavesPerSU = numNetworkCardsPerServer;
                
                // 显示第一个SU的叶子
                for (let i = 0; i < leavesPerSU; i++) {
                    leavesToDisplay.push(i);
                }
                
                // 显示最后一个SU的叶子
                const lastSUStartIndex = numLeaf - leavesPerSU;
                for (let i = lastSUStartIndex; i < numLeaf; i++) {
                    // 仅添加未添加的（避免少数SU的情况下重复）
                    if (!leavesToDisplay.includes(i)) {
                        leavesToDisplay.push(i);
                    }
                }
                
                // 排序以保持顺序
                leavesToDisplay.sort((a, b) => a - b);
            }
            
            // 计算leaf交换机X位置的函数
            const leafX = d => {
                if (numSU <= 2 || numLeaf <= 8) {
                    // 少数SU时计算所有叶子的位置
                    return (width / (numLeaf + 1)) * (d + 1);
                } else {
                    // 我们需要修复叶子的间距
                    const leavesPerSide = leavesToDisplay.length / 2;
                    
                    // 确定这是上半部分还是下半部分的叶子
                    if (d < numNetworkCardsPerServer) {
                        // 第一个SU的叶子
                        const index = d;
                        // 位于屏幕左侧40%，间距适当
                        return width * (0.01 + 0.5 * (index + 1) / (leavesPerSide + 1));
                    } else {
                        // 最后一个SU的叶子
                        const index = d - (numLeaf - numNetworkCardsPerServer);
                        // 位于屏幕右侧40%，间距适当
                        return width * (0.5 + 0.5 * (index + 1) / (leavesPerSide + 1));
                    }
                }
            };
            
            // 仅为显示的leaf创建矩形
            leavesToDisplay.forEach(leafIndex => {
                const x = leafX(leafIndex);
                const rect = nodesGroup.append("rect")
                    .attr("class", "leaf")
                    .attr("x", x - 30)
                    .attr("y", leafY)
                    .attr("width", 60)
                    .attr("height", 30)
                    .attr("rx", 4)
                    .attr("ry", 4);
                    
                // 添加鼠标悬停事件
                rect.on("mouseover", function(event) {
                    showTooltip(event, `Leaf ${leafIndex + 1}<br>连接到 ${spinesToDisplay.length} 个Spine`);
                })
                .on("mousemove", function(event) {
                    moveTooltip(event);
                })
                .on("mouseout", function() {
                    hideTooltip();
                });
                    
                nodesGroup.append("text")
                    .attr("class", "leaf-label")
                    .attr("x", x)
                    .attr("y", leafY + 15)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "white")
                    .text(`Leaf ${leafIndex + 1}`);
            });
            
            // 如果不显示所有leaf，添加省略号
            if (numSU > 2 && numLeaf > 8) {
                nodesGroup.append("text")
                    .attr("x", width / 2)
                    .attr("y", leafY + 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#05d9e8")
                    .text("...");
            }
            
            // 创建显示的spine和leaf之间的曲线连接
            leavesToDisplay.forEach(l => {
                spinesToDisplay.forEach(s => {
                    const startX = spineX(s);
                    const startY = spineY + 30;
                    const endX = leafX(l);
                    const endY = leafY;
                    const midY = (startY + endY) / 2;
                    
                    // 使用更平滑的曲线
                    connectionsGroup.append("path")
                        .attr("d", `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`)
                        .attr("fill", "none")
                        .attr("stroke", "rgba(255, 255, 255, 0.15)")
                        .attr("stroke-width", 0.5);
                });
            });
            
            // 服务器节点的常量
            const serverWidth = 50;
            const serverHeight = 20;
            
            // 根据一行中的服务器数量和可用宽度调整服务器间距
            let serverSpacing;
            if (numSU <= 2) {
                // 对于包含所有SU的普通视图
                serverSpacing = Math.min(60, (width / numSU) / (serversPerRow + 1));
            } else {
                // 对于仅包含第一个和最后一个SU的简化视图
                // 使用更多空间，因为我们只显示2个SU而不是全部
                serverSpacing = Math.min(60, (width / 2) / (serversPerRow + 1));
            }
            
            const totalRows = Math.ceil(Math.max(...Array.from({ length: numSU }, (_, i) => 
                Math.min(serversPerSU, numServers - i * serversPerSU)
            )) / serversPerRow);
            
            const totalServerHeight = (totalRows - 1) * nodeRowSpacing;
            const availableHeight = height - serverY - 60;
            const verticalScale = Math.min(1, availableHeight / totalServerHeight);
            
            // 确定基于总数量显示哪些SU
            let susToDisplay = [];
            if (numSU <= 2) {
                // 如果2个或更少SU，显示所有
                susToDisplay = Array.from({ length: numSU }, (_, i) => i);
            } else {
                // 如果3个或更多SU，仅显示第一个和最后一个SU
                susToDisplay = [0, numSU - 1];
            }
            
            let lastNodeY = 0;
            
            // 仅为要显示的SU渲染服务器
            susToDisplay.forEach(su => {
                const serversInThisSU = Math.min(serversPerSU, numServers - su * serversPerSU);
                
                for (let s = 0; s < serversInThisSU; s++) {
                    const row = Math.floor(s / serversPerRow);
                    const col = s % serversPerRow;
                    
                    // 调整仅显示第一个和最后一个SU时的x坐标计算
                    let x;
                    if (numSU <= 2) {
                        // 对于2个或更少SU - 均匀分布
                        x = width * ((su + 0.5) / numSU) + (col - serversPerRow / 2 + 0.5) * serverSpacing;
                    } else {
                        // 对于3个或更多SU的第一个和最后一个SU
                        // 放置在宽度的1/4和3/4处，间距适当
                        const suPosition = su === 0 ? 0.25 : 0.75;
                        x = width * suPosition + (col - serversPerRow / 2 + 0.5) * serverSpacing;
                    }
                    
                    const y = serverY + row * nodeRowSpacing * verticalScale;
                    lastNodeY = Math.max(lastNodeY, y);
                    
                    // 计算节点的唯一ID
                    const nodeId = su * serversPerSU + s + 1;
                    
                    const rect = nodesGroup.append("rect")
                        .attr("class", "server")
                        .attr("x", x - serverWidth / 2)
                        .attr("y", y - serverHeight / 2)
                        .attr("width", serverWidth)
                        .attr("height", serverHeight)
                        .attr("rx", 5)
                        .attr("ry", 5);
                    
                    // 添加鼠标悬停事件
                    rect.on("mouseover", function(event) {
                        showTooltip(event, `Node ${nodeId}<br>${numNetworkCardsPerServer} 网卡<br>SU ${su + 1}`);
                    })
                    .on("mousemove", function(event) {
                        moveTooltip(event);
                    })
                    .on("mouseout", function() {
                        hideTooltip();
                    });
                    
                    nodesGroup.append("text")
                        .attr("class", "server-label")
                        .attr("x", x)
                        .attr("y", y)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", "8px")
                        .attr("fill", "white")
                        .text(`Node ${nodeId}`);
                    
                    // 创建leaf交换机和服务器之间的曲线连接
                    // 仅创建到可见leaf交换机的连接
                    if (leavesToDisplay.length > 0) {
                        // 确定连接到此服务器的leaf交换机
                        let connectedLeaves = [];
                        
                        if (numSU <= 2 || numLeaf <= 8) {
                            // 显示所有叶子时，连接到此SU的正确叶子
                            for (let nc = 0; nc < numNetworkCardsPerServer; nc++) {
                                const leafIndex = su * numNetworkCardsPerServer + nc;
                                if (leafIndex < numLeaf) {
                                    connectedLeaves.push(leafIndex);
                                }
                            }
                        } else {
                            // 仅显示部分叶子时，建立逻辑连接：
                            if (su === 0) {
                                // 第一个SU服务器连接到第一个SU叶子（leavesToDisplay的前半部分）
                                connectedLeaves = leavesToDisplay.filter(l => l < numNetworkCardsPerServer);
                            } else if (su === numSU - 1) {
                                // 最后一个SU服务器连接到最后一个SU叶子（leavesToDisplay的后半部分）
                                connectedLeaves = leavesToDisplay.filter(l => l >= numLeaf - numNetworkCardsPerServer);
                            }
                        }
                        
                        // 创建连接
                        connectedLeaves.forEach(leafIndex => {
                            if (leavesToDisplay.includes(leafIndex)) {
                                const startX = leafX(leafIndex);
                                const startY = leafY + 30;
                                const endX = x;
                                const endY = y - serverHeight / 2;
                                const midY = (startY + endY) / 2;
                                
                                const path = connectionsGroup.append("path")
                                    .attr("d", `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`)
                                    .attr("fill", "none")
                                    .attr("stroke", "rgba(255, 255, 255, 0.1)")
                                    .attr("stroke-width", 0.5);
                                    
                                // 添加动画效果
                                if (Math.random() > 0.8) {
                                    animateConnectionFlow(path);
                                }
                            }
                        });
                    }
                }
            });
            
            // 添加标题标签
            nodesGroup.append("text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "rgba(255, 255, 255, 0.9)")
                .text("Spine 交换机");
            
            nodesGroup.append("text")
                .attr("x", width / 2)
                .attr("y", leafY - 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "rgba(255, 255, 255, 0.9)")
                .text("Leaf 交换机");
            
            nodesGroup.append("text")
                .attr("x", width / 2)
                .attr("y", serverY - 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "rgba(255, 255, 255, 0.9)")
                .text("服务器");
            
            // 绘制SU边界框
            susToDisplay.forEach(su => {
                // 基于是否显示所有SU或仅第一个/最后一个计算x位置
                let xPosition, boxWidth;
                
                if (numSU <= 2) {
                    // 2个或更少SU的原始计算
                    xPosition = (width / numSU) * su;
                    boxWidth = width / numSU;
                } else {
                    // 3个或更多SU的第一个和最后一个SU的修改计算
                    if (su === 0) {
                        xPosition = 0;
                        boxWidth = width / 2;
                    } else {
                        xPosition = width / 2;
                        boxWidth = width / 2;
                    }
                }
                
                connectionsGroup.append("rect")
                    .attr("x", xPosition)
                    .attr("y", 10)
                    .attr("width", boxWidth)
                    .attr("height", lastNodeY + 60)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(255, 255, 255, 0.2)")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "5,5");
                
                // 仅当这是第一个SU且有3+个SU且尚未在其他地方添加省略号时添加省略号文本
                if (numSU > 2 && su === 0 && !(numLeaf > 8)) { 
                    // 仅当我们在叶子中没有省略号时才在此处添加省略号
                    nodesGroup.append("text")
                        .attr("x", width / 2)
                        .attr("y", lastNodeY + 40)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "rgba(255, 255, 255, 0.7)")
                        .text("...");
                }
                
                let suLabel = `SU${su + 1}`;
                if (numSU > 2 && su === numSU - 1) {
                    suLabel = `SU${numSU}`;  // 确保最后一个SU显示正确的SU编号
                }
                
                let labelX;
                if (numSU <= 2) {
                    labelX = xPosition + boxWidth / 2;
                } else {
                    labelX = su === 0 ? width / 4 : width * 3/4;
                }
                
                const badge = nodesGroup.append("rect")
                    .attr("x", labelX - 30)
                    .attr("y", lastNodeY + 30)
                    .attr("width", 60)
                    .attr("height", 24)
                    .attr("rx", 12)
                    .attr("ry", 12)
                    .attr("fill", "rgba(1, 195, 141, 0.2)")
                    .attr("stroke", "rgba(1, 195, 141, 0.5)")
                    .attr("stroke-width", 1);
                
                nodesGroup.append("text")
                    .attr("x", labelX)
                    .attr("y", lastNodeY + 42)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .attr("fill", "rgba(255, 255, 255, 0.9)")
                    .text(suLabel);
            });
            
            // 执行自动缩放以适应图表
            zoomToFit();
        }
        
        function animateConnectionFlow(path) {
            // 创建流动动画效果
            path.append("animate")
                .attr("attributeName", "stroke-dasharray")
                .attr("from", "0,12,0,12")
                .attr("to", "12,12,12,12")
                .attr("dur", "1.5s")
                .attr("repeatCount", "indefinite");
                
            path.append("animate")
                .attr("attributeName", "stroke")
                .attr("from", "rgba(5, 217, 232, 0.7)")
                .attr("to", "rgba(255, 255, 255, 0.1)")
                .attr("dur", "1.5s")
                .attr("repeatCount", "indefinite");
        }
        
        function toggleGrid() {
            const grid = svg.select(".grid");
            const button = document.getElementById('toggleGridBtn');
            
            if (grid.attr("display") === "none") {
                grid.attr("display", "block");
                button.classList.add("active");
            } else {
                grid.attr("display", "none");
                button.classList.remove("active");
            }
        }
        
        function zoomToFit() {
            // 获取图表的边界框
            if (!svg) return;
            
            const svgNode = svg.node();
            if (!svgNode) return;
            
            const bounds = svgNode.getBBox();
            const parent = svgNode.parentElement;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            
            const width = bounds.width;
            const height = bounds.height;
            
            // 计算合适的缩放比例
            const scale = 0.95 * Math.min(fullWidth / width, fullHeight / height);
            
            // 计算平移量以居中
            const dx = (fullWidth - width * scale) / 2;
            const dy = (fullHeight - height * scale) / 2;
            
            // 应用变换
            svg.transition()
                .duration(750)
                .call(
                    d3.zoom().transform,
                    d3.zoomIdentity.translate(dx, dy).scale(scale)
                );
        }
        
        function exportSVG() {
            if (!svg) return;
            
            // 获取SVG内容
            const svgData = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
            const svgUrl = URL.createObjectURL(svgBlob);
            
            // 创建下载链接
            const downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "network_topology.svg";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            updateStatusText("已导出SVG");
        }
        
        function resetParameters() {
            document.getElementById('switchType').value = 'QM9700';
            document.getElementById('networkCardType').value = '400G';
            document.getElementById('numServers').value = '128';
            document.getElementById('numNetworkCardsPerServer').value = '8';
            document.getElementById('serversPerRow').value = '8';
            document.getElementById('diagramHeight').value = '1000';
            document.getElementById('spineLeafDistance').value = '200';
            document.getElementById('leafNodeDistance').value = '120';
            document.getElementById('nodeRowSpacing').value = '60';
            
            spineLeafValue.textContent = '200px';
            leafNodeValue.textContent = '120px';
            nodeRowValue.textContent = '60px';
            
            updateStatusText("参数已重置");
        }
        
        function showTooltip(event, content) {
            tooltip.innerHTML = content;
            tooltip.style.left = (event.pageX) + 'px';
            tooltip.style.top = (event.pageY) + 'px';
            tooltip.style.opacity = 1;
        }
        
        function moveTooltip(event) {
            tooltip.style.left = (event.pageX) + 'px';
            tooltip.style.top = (event.pageY) + 'px';
        }
        
        function hideTooltip() {
            tooltip.style.opacity = 0;
        }
        
        function showLoading() {
            // 创建加载指示器
            const loading = document.createElement('div');
            loading.className = 'loading';
            loading.id = 'loadingIndicator';
            
            const loader = document.createElement('div');
            loader.className = 'loader';
            loading.appendChild(loader);
            
            document.getElementById('diagram-container').appendChild(loading);
        }
        
        function hideLoading() {
            const loading = document.getElementById('loadingIndicator');
            if (loading) {
                loading.remove();
            }
        }
        
        function updateStatusText(text) {
            document.getElementById('statusText').textContent = text;
        }
        
        // 监听窗口大小变化，调整图表
        window.addEventListener('resize', debounce(function() {
            if (svg) {
                zoomToFit();
            }
        }, 250));
        
        // 防抖函数，避免频繁调用
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }
        
        // 添加拖动功能
        document.getElementById('diagram-container').addEventListener('mousedown', function(e) {
            if (e.target.tagName === 'svg' || e.target.closest('svg')) {
                isDragging = true;
                lastX = e.pageX;
                lastY = e.pageY;
                document.getElementById('diagram-container').style.cursor = 'grabbing';
            }
        });
        
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const dx = e.pageX - lastX;
                const dy = e.pageY - lastY;
                lastX = e.pageX;
                lastY = e.pageY;
                
                // 获取当前变换
                const transform = d3.zoomTransform(svg.node());
                // 应用新的平移
                const newTransform = transform.translate(dx / transform.k, dy / transform.k);
                // 应用变换
                svg.call(d3.zoom().transform, newTransform);
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                document.getElementById('diagram-container').style.cursor = 'auto';
            }
        });
        
        // 添加滚轮缩放功能
        document.getElementById('diagram-container').addEventListener('wheel', function(e) {
            if (svg) {
                e.preventDefault();
                const direction = e.deltaY < 0 ? 1 : -1;
                const transform = d3.zoomTransform(svg.node());
                const scale = transform.k * (1 + direction * 0.1);
                const newScale = Math.max(0.1, Math.min(10, scale));
                
                // 计算缩放中心点
                const point = d3.pointer(e, svg.node());
                
                // 应用新的缩放
                const newTransform = transform.scale(newScale / transform.k, point[0], point[1]);
                
                // 应用变换
                svg.call(d3.zoom().transform, newTransform);
            }
        });
    });
    </script>
</body>
</html>
